<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307881 (zh-CN, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="418"/>

<div>
<span><div><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">第一章   欢迎来到Python世界</span></font></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">第一节  什么是python</span></font></div><div> python：强大的，可以进行系统调用的解释型脚本语言。这意味着开发环节中没有了编译这个环节。</div><div> 特点：</div><ol><li><div> 高级：</div></li><li><div>面向对象</div></li><li><div>可升级</div></li><li><div>可扩展</div></li><li><div>可移植性</div></li><li><div>易学、易读、易维护、健壮性</div></li></ol><div> 源文件的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">扩展名</span>通常都是 <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">.py</span></div><div>C语言是可以用来编写操作系统的贴近硬件的语言，所以，C语言适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。</div></div><div><br/></div><div>缺点：</div><ol><li><div>第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</div></li><li><div>第二个缺点就是代码不能加密。如果要发布你的Python程序，实际上就是发布源代码，这一点跟C语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。</div></li></ol><div><br/></div><div>Python是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">跨平台</span>的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。</div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">第二节  第一个python程序</span></font></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">输入和输出函数（I/O）：input()  print()</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">name = input('please input your name:')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">print('hello,', name)</span></div></div><div>运行python程序：</div><div><a href="Python核心编程（第二版） Wesley J_files/run-hello.py.mp4"><img src="Python核心编程（第二版） Wesley J_files/594227b14558a03aeafa185f4e5e254c.png" alt="run-hello.py.mp4"></a></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">扩展章节：廖雪峰关于python的教程</span></font></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第一节：Python基础知识</span></div><div><span style="background-color: rgb(255, 250, 165);font-size: 10pt;-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 10pt; font-weight: bold;-evernote-highlight:true;">1.1数据类型和变量</span></span><span style="font-size: 10pt;">：整数、浮点数、字符串（字符串是以单引号'或双引号&quot;括起来的任意文本，比如'abc'，&quot;xyz&quot;等等。请注意，''或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I'm OK&quot;包含的字符是I，'，m，空格，O，K这6个字符。如果字符串内部既包含'又包含&quot;怎么办？可以用转义字符\来标识，比如：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">'I\'m \&quot;OK\&quot;!'</span></div></div><div>表示的是</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">I'm &quot;OK&quot;!</span></div></div><div>此外，Python允许用'''...'''的格式表示多行内容，如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; print('''line1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">... line2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">... line3''')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">line1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">line2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">line3</span></div></div><div>多行字符串'''...'''还可以在前面加上r使用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">print(r'''hello,\n</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">world''')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">hello,\n</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">world</span></div></div><div>布尔值：布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 3 &gt; 2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 3 &gt; 5</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div></div><div>布尔值可以用and、or和not运算</div><hr style="display:none;-evernote-encp-section-break:true;"/><div>and</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; True and True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; True and False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; False and False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div></div><div>or</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; True or True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; True or False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; False or False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div></div><div><span style="font-size: 10pt;">not</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; not True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; not False</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; not 1 &gt; 2</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">True</span></div></div><div>布尔值经常用在条件判断中，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">if age &gt;= 18:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    print('adult')</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">else:</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">    print('teenager')</span></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">空值</span>：空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">a = 123 <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"># a是整数，此处注意在python中注释使用#表示</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">print(a)</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">a = 'ABC' # a变为字符串</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">print(a)</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">123</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">ABC</span></div></div><div>这种变量本身类型不固定的语言称之为<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">动态语言</span>，与之对应的是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">静态语言</span>。<span style="text-decoration: underline;">python是不需要定义变量的，直接用就可以了</span>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">int a = 123; // a是整数类型变量</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量</span></div></div><div>最后，关于除法计算，有：/除法计算结果是浮点数。还有一种除法是//，称为地板除，两个整数的除法仍然是整数。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 10 / 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">3.3333333333333335</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 9 / 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">3.0</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 10 // 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">&gt;&gt;&gt; 10 % 3</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">1</span></div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意</span>：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。</div><div>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</div><div><br/></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1.2字符串和编码</span>：</span> Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。ASCII编码是1个字节，而Unicode编码通常是2个字节。</div><div>总结一下现在计算机系统通用的字符编码工作方式：</div><div>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</div><div><img src="Python核心编程（第二版） Wesley J_files/0.png" type="image/png" data-filename="0.png"/></div><div>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</div><div><img src="Python核心编程（第二版） Wesley J_files/1.png" type="image/png" data-filename="1.png"/></div><div>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; print('包含中文的str')</div><div>包含中文的str</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符</span>：order？character？</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; ord('A')</div><div>65</div><div>&gt;&gt;&gt; ord('中')</div><div>20013</div><div>&gt;&gt;&gt; chr(66)</div><div>'B'</div><div>&gt;&gt;&gt; chr(25991)</div><div>'文'</div></div><div>Python对bytes类型的数据用带b前缀的单引号或双引号表示。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>x = b'ABC'</div></div><div>要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的<span style="text-decoration: underline;">每个字符</span>都只占用一个字节。</div><div>以Unicode表示的str通过<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">encode()</span>方法可以编码为指定的bytes，例如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'ABC'.encode('ascii')</div><div>b'ABC'</div><div>&gt;&gt;&gt; '中文'.encode('utf-8')</div><div>b'\xe4\xb8\xad\xe6\x96\x87'</div><div>&gt;&gt;&gt; '中文'.encode('ascii')</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)</div></div><div>纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。</div><div>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">decode()</span>方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; b'ABC'.decode('ascii')</div><div>'ABC'</div><div>&gt;&gt;&gt; b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')</div><div>'中文'</div></div><div>如果bytes中包含无法解码的字节，decode()方法会报错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; b'\xe4\xb8\xad\xff'.decode('utf-8')</div><div>Traceback (most recent call last):</div><div>  ...</div><div>UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte</div></div><div>如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')</div><div>'中'</div></div><div>要计算str包含多少个字符，可以用<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">len()</span>函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; len('ABC')</div><div>3</div><div>&gt;&gt;&gt; len('中文')</div><div>2</div></div><div>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; len(b'ABC')</div><div>3</div><div>&gt;&gt;&gt; len(b'\xe4\xb8\xad\xe6\x96\x87')</div><div>6</div><div>&gt;&gt;&gt; len('中文'.encode('utf-8'))</div><div>6</div></div><div>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</div><div><br/></div><div>在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。</div><div>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#!/usr/bin/env python3</div><div># -*- coding: utf-8 -*-</div></div><div>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</div><div>申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：</div><div><img src="Python核心编程（第二版） Wesley J_files/001427719248811c5f9fd37acf54f6f93d7affbd80dd79b000.png" type="image/png" data-filename="001427719248811c5f9fd37acf54f6f93d7affbd80dd79b000.png"/></div><div>如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文：</div><div><img src="Python核心编程（第二版） Wesley J_files/0014277193240041efdda5a5de14f58a0879d8d4efcee66000.png" type="image/png" data-filename="0014277193240041efdda5a5de14f58a0879d8d4efcee66000.png"/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">格式化#下面的例子均需要加print()才能输出，原著略写了。</span></div><div>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'Hello, %s' % 'world'</div><div>'Hello, world'</div><div>&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)</div><div>'Hi, Michael, you have $1000000.'</div></div><div>在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</div><div>常用的占位符有：</div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>占位符</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>替换内容</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>%d</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>整数</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>%f</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>浮点数</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>%s</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>字符串</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>%x</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>十六进制整数</div></td></tr></tbody></table><div>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>print('%2d-%02d' % (3, 1))</div><div>print('%.2f' % 3.1415926)</div><div>3-01</div><div>3.14</div></div><div>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)</div><div>'Age: 25. Gender: True'</div></div><div>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'growth rate: %d %%' % 7</div><div>'growth rate: 7 %'</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">format()</span>   另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)</div><div>'Hello, 小明, 成绩提升了 17.1%'</div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1.3使用list和tuple (注意类比数组)</span></div><div>list：Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</div><div>比如，列出班里所有同学的名字，就可以用一个list表示：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Bob', 'Tracy']</div><div><br/></div><div>&gt;&gt;&gt; len(classmates)</div><div>3</div><div><br/></div><div>&gt;&gt;&gt; classmates[0]</div><div>'Michael'</div><div>&gt;&gt;&gt; classmates[1]</div><div>'Bob'</div><div>&gt;&gt;&gt; classmates[2]</div><div>'Tracy'</div><div>&gt;&gt;&gt; classmates[3]</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>IndexError: list index out of range</div></div><div>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素，以此类推，可以获取倒数第2个、倒数第3个：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates[-1]</div><div>'Tracy'</div><div>&gt;&gt;&gt; classmates[-2]</div><div>'Bob'</div><div>&gt;&gt;&gt; classmates[-3]</div><div>'Michael'</div><div>&gt;&gt;&gt; classmates[-4]</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>IndexError: list index out of range</div></div><div>list是一个可变的有序表，所以，可以往list中追加元素到末尾：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates.append('Adam')</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Bob', 'Tracy', 'Adam']</div></div><div>也可以把元素插入到指定的位置，比如索引号为1的位置：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates.insert(1, 'Jack')</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']</div></div><div>要删除list末尾的元素，用pop()方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates.pop()</div><div>'Adam'</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Jack', 'Bob', 'Tracy']</div></div><div>要删除指定位置的元素，用pop(i)方法，其中i是索引位置：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates.pop(1)</div><div>'Jack'</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Bob', 'Tracy']</div></div><div>要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates[1] = 'Sarah'</div><div>&gt;&gt;&gt; classmates</div><div>['Michael', 'Sarah', 'Tracy']</div></div><div>list里面的元素的数据类型也可以不同，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = ['Apple', 123, True]</div></div><div>list元素也可以是另一个list，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']</div><div>&gt;&gt;&gt; len(s)</div><div>4</div></div><div>要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; p = ['asp', 'php']</div><div>&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']</div></div><div>要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。</div><div>如果一个list中一个元素也没有，就是一个空的list，它的长度为0</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = []</div><div>&gt;&gt;&gt; len(L)</div><div>0</div></div><div><br/></div><div>tuple:另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')</div></div><div>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</div><div>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</div><div>tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; t = (1, 2)</div><div>&gt;&gt;&gt; t</div><div>(1, 2)</div></div><div>如果要定义一个空的tuple，可以写成()：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; t = ()</div><div>&gt;&gt;&gt; t</div><div>()</div></div><div>但是，要定义一个只有1个元素的tuple，如果你这么定义：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; t = (1)</div><div>&gt;&gt;&gt; t</div><div>1</div></div><div>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</div><div>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; t = (1,)</div><div>&gt;&gt;&gt; t</div><div>(1,)</div></div><div>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</div><div>最后来看一个“可变的”tuple：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])</div><div>&gt;&gt;&gt; t[2][0] = 'X'</div><div>&gt;&gt;&gt; t[2][1] = 'Y'</div><div>&gt;&gt;&gt; t</div><div>('a', 'b', ['X', 'Y'])</div></div><div>这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</div><div>别急，我们先看看定义的时候tuple包含的3个元素：</div><div><img src="Python核心编程（第二版） Wesley J_files/0 [1].png" type="image/png" data-filename="0.png"/></div><div>当我们把list的元素'A'和'B'修改为'X'和'Y'后，tuple变为：</div><div><img src="Python核心编程（第二版） Wesley J_files/1 [1].png" type="image/png" data-filename="1.png"/></div><div>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</div><div>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1.4条件判断</span></div><div>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</div><div>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>age = 20</div><div>if age &gt;= 18:</div><div>    print('your age is', age)</div><div>    print('adult')</div></div><div>根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。</div><div>也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>age = 3</div><div>if age &gt;= 18:</div><div>    print('your age is', age)</div><div>    print('adult')</div><div>else:</div><div>    print('your age is', age)</div><div>    print('teenager')</div></div><div>注意不要少写了冒号:。</div><div>当然上面的判断是很粗略的，完全可以用elif做更细致的判断：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>age = 3</div><div>if age &gt;= 18:</div><div>    print('adult')</div><div>elif age &gt;= 6:</div><div>    print('teenager')</div><div>else:</div><div>    print('kid')</div></div><div>elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if &lt;条件判断1&gt;:</div><div>    &lt;执行1&gt;</div><div>elif &lt;条件判断2&gt;:</div><div>    &lt;执行2&gt;</div><div>elif &lt;条件判断3&gt;:</div><div>    &lt;执行3&gt;</div><div>else:</div><div>    &lt;执行4&gt;</div></div><div>if判断条件还可以简写，比如写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if x:</div><div>    print('True')</div></div><div>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。</div><div>再议 input</div><div>最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>birth = input('birth: ')</div><div>if birth &lt; 2000:</div><div>    print('00前')</div><div>else:</div><div>    print('00后')</div></div><div>输入1982，结果报错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: unorderable types: str() &gt; int()</div></div><div>这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = input('birth: ')</div><div>birth = int(s)</div><div>if birth &lt; 2000:</div><div>    print('00前')</div><div>else:</div><div>    print('00后')</div></div><div>再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>ValueError: invalid literal for int() with base 10: 'abc'</div></div><div>原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。</div><div>如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">小知识：平方的表示方法:2**5=32,表示2的5次方，同pow(2,5)</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1.5循环</span></div><div>为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。</div><div>Python的循环有两种，一种是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">for...in循环</span>，依次把list或tuple中的每个元素迭代出来，看例子：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>names = ['Michael', 'Bob', 'Tracy']</div><div>for name in names:</div><div>    print(name)</div></div><div>执行这段代码，会依次打印names的每一个元素：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Michael</div><div>Bob</div><div>Tracy</div></div><div>所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。</div><div>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sum = 0</div><div>for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</div><div>    sum = sum + x</div><div>print(sum)</div></div><div>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; list(range(5))</div><div>[0, 1, 2, 3, 4]</div></div><div>range(101)就可以生成0-100的整数序列，计算如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sum = 0</div><div>for x in range(101):</div><div>    sum = sum + x</div><div>print(sum)</div><div><br/></div><div><br/></div><div>5050</div></div><div>第二种循环是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">while循环</span>，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sum = 0</div><div>n = 99</div><div>while n &gt; 0:</div><div>    sum = sum + n</div><div>    n = n - 2  <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">#此处可以看出python的特点，必须保持格式的对齐，缩进的格式不同，会运行处不同的结果</span></div><div>print(sum)</div></div><div>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">break</span></div><div>在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>n = 1</div><div>while n &lt;= 100:</div><div>    print(n)</div><div>    n = n + 1</div><div>print('END')</div></div><div>上面的代码可以打印出1~100。</div><div>如果要提前结束循环，可以用break语句：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>n = 1</div><div>while n &lt;= 100:</div><div>    if n &gt; 10: # 当n = 11时，条件满足，执行break语句</div><div>        break # break语句会结束当前循环</div><div>    print(n)</div><div>    n = n + 1</div><div>print('END')</div></div><div>执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。</div><div>可见break的作用是提前结束循环。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">continue</span></div><div>在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>n = 0</div><div>while n &lt; 10:</div><div>    n = n + 1</div><div>    print(n)</div></div><div>上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>n = 0</div><div>while n &lt; 10:</div><div>    n = n + 1</div><div>    if n % 2 == 0: # 如果n是偶数，执行continue语句</div><div>        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行</div><div>    print(n)</div></div><div>执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。</div><div>可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。</div><div>循环是让计算机做重复任务的有效的方法。</div><div>break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。</div><div>要特别注意，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。</span>大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。</div><div>有些时候，如果代码写得有问题，会让<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程</span>。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">1.6</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">使用dict和set</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">dict</span></div><div>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</div><div>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>names = ['Michael', 'Bob', 'Tracy']</div><div>scores = [95, 75, 85]</div></div><div>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。</div><div>如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}</div><div>&gt;&gt;&gt; d['Michael']</div><div>95</div></div><div>为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。</div><div>第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。</div><div>dict就是第二种实现方式，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。</div><div>你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。</div><div>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d['Adam'] = 67</div><div>&gt;&gt;&gt; d['Adam']</div><div>67</div></div><div>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d['Jack'] = 90</div><div>&gt;&gt;&gt; d['Jack']</div><div>90</div><div>&gt;&gt;&gt; d['Jack'] = 88</div><div>&gt;&gt;&gt; d['Jack']</div><div>88</div></div><div>如果key不存在，dict就会报错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d['Thomas']</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>KeyError: 'Thomas'</div></div><div>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'Thomas' in d</div><div>False</div></div><div>二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d.get('Thomas')</div><div>&gt;&gt;&gt; d.get('Thomas', -1)</div><div>-1</div></div><div>注意：返回None的时候Python的交互环境不显示结果。</div><div>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d.pop('Bob')</div><div>75</div><div>&gt;&gt;&gt; d</div><div>{'Michael': 95, 'Tracy': 85}</div></div><div>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</div><div>和list比较，dict有以下几个特点：</div><ol><li><div>查找和插入的速度极快，不会随着key的增加而变慢；</div></li><li><div>需要占用大量的内存，内存浪费多。</div></li></ol><div>而list相反：</div><ol><li><div>查找和插入的时间随着元素的增加而增加；</div></li><li><div>占用空间小，浪费内存很少。</div></li></ol><div>所以，dict是用空间来换取时间的一种方法。</div><div>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</div><div>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">哈希算法（Hash）</span>。</div><div>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">set</span></div><div>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</div><div>要创建一个set，需要提供一个list作为输入集合：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = set([1, 2, 3])</div><div>&gt;&gt;&gt; s</div><div>{1, 2, 3}</div></div><div>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。</div><div>重复元素在set中自动被过滤：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</div><div>&gt;&gt;&gt; s</div><div>{1, 2, 3}</div></div><div>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s.add(4)</div><div>&gt;&gt;&gt; s</div><div>{1, 2, 3, 4}</div><div>&gt;&gt;&gt; s.add(4)</div><div>&gt;&gt;&gt; s</div><div>{1, 2, 3, 4}</div></div><div>通过remove(key)方法可以删除元素：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s.remove(4)</div><div>&gt;&gt;&gt; s</div><div>{1, 2, 3}</div></div><div>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s1 = set([1, 2, 3])</div><div>&gt;&gt;&gt; s2 = set([2, 3, 4])</div><div>&gt;&gt;&gt; s1 &amp; s2</div><div>{2, 3}</div><div>&gt;&gt;&gt; s1 | s2</div><div>{1, 2, 3, 4}</div></div><div>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第二节：函数及其调用</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">2.1调用函数</span></div><div>Python内置了很多有用的函数，我们可以直接调用。</div><div>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：</div><div><a href="http://docs.python.org/3/library/functions.html#abs">http://docs.python.org/3/library/functions.html#abs</a></div><div>也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。</div><div>调用<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">abs函数</span>：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; abs(100)</div><div>100</div><div>&gt;&gt;&gt; abs(-20)</div><div>20</div><div>&gt;&gt;&gt; abs(12.34)</div><div>12.34</div></div><div>而max函数<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">max()</span>可以接收任意多个参数，并返回最大的那个：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; max(1, 2)</div><div>2</div><div>&gt;&gt;&gt; max(2, 3, 1, -5)</div><div>3</div></div><div>Python内置的常用函数还包括数据类型转换函数，比如<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">int()</span>函数可以把其他数据类型转换为整数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; int('123')</div><div>123</div><div>&gt;&gt;&gt; int(12.34)</div><div>12</div><div>&gt;&gt;&gt; float('12.34')</div><div>12.34</div><div>&gt;&gt;&gt; str(1.23)</div><div>'1.23'</div><div>&gt;&gt;&gt; str(100)</div><div>'100'</div><div>&gt;&gt;&gt; bool(1)</div><div>True</div><div>&gt;&gt;&gt; bool('')</div><div>False</div></div><div>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; a = abs # 变量a指向abs函数</div><div>&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</div><div>1</div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">2.2定义函数</span></div><div>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</div><div>我们以自定义一个求绝对值的my_abs函数为例：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def my_abs(x):</div><div>    if x &gt;= 0:</div><div>        return x</div><div>    else:</div><div>        return -x</div></div><div>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</div><div>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</div><div>在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：</div><div><img src="Python核心编程（第二版） Wesley J_files/1.PNG" type="image/png" data-filename="1.PNG"/></div><div>如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：</div><div><img src="Python核心编程（第二版） Wesley J_files/2.PNG" type="image/png" data-filename="2.PNG"/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">空函数</span></div><div>如果想定义一个什么事也不做的空函数，可以用pass语句：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def nop():</div><div>    pass</div></div><div>pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。</div><div>pass还可以用在其他语句里，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if age &gt;= 18:</div><div>    pass</div></div><div>缺少了pass，代码运行就会有语法错误。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">参数检查</span></div><div>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; my_abs(1, 2)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: my_abs() takes 1 positional argument but 2 were given</div></div><div>但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; my_abs('A')</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>  File &quot;&lt;stdin&gt;&quot;, line 2, in my_abs</div><div>TypeError: unorderable types: str() &gt;= int()</div><div>&gt;&gt;&gt; abs('A')</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: bad operand type for abs(): 'str'</div></div><div>当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。</div><div>让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def my_abs(x):</div><div>    if not isinstance(x, (int, float)):</div><div>        raise TypeError('bad operand type')</div><div>    if x &gt;= 0:</div><div>        return x</div><div>    else:</div><div>        return -x</div></div><div>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div> &gt;&gt;&gt; my_abs('A')</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</div><div>TypeError: bad operand type</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">返回多个值</span></div><div>函数可以返回多个值吗？答案是肯定的。</div><div>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import math</div><div><br/></div><div>def move(x, y, step, angle=0):</div><div>    nx = x + step * math.cos(angle)</div><div>    ny = y - step * math.sin(angle)</div><div>    return nx, ny</div></div><div>import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。</div><div>然后，我们就可以同时获得返回值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</div><div>&gt;&gt;&gt; print(x, y)</div><div>151.96152422706632 70.0</div></div><div>但其实这只是一种假象，Python函数返回的仍然是单一值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</div><div>&gt;&gt;&gt; print(r)</div><div>(151.96152422706632, 70.0)</div></div><div>原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">2.3函数的参数</span></div><div>定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。</div><div>Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">位置参数</span></div><div>我们先写一个计算x2的函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def power(x):</div><div>    return x * x</div></div><div>对于power(x)函数，参数x就是一个位置参数。</div><div>当我们调用power函数时，必须传入有且仅有的一个参数x：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; power(5)</div><div>25</div><div>&gt;&gt;&gt; power(15)</div><div>225</div></div><div>现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。</div><div>你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def power(x, n):</div><div>    s = 1</div><div>    while n &gt; 0:</div><div>        n = n - 1</div><div>        s = s * x</div><div>    return s</div></div><div>对于这个修改后的power(x, n)函数，可以计算任意n次方：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; power(5, 2)</div><div>25</div><div>&gt;&gt;&gt; power(5, 3)</div><div>125</div></div><div>修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">默认参数</span></div><div>新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; power(5)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: power() missing 1 required positional argument: 'n'</div></div><div>Python的错误信息很明确：调用函数power()缺少了一个位置参数n。</div><div>这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def power(x, n=2):</div><div>    s = 1</div><div>    while n &gt; 0:</div><div>        n = n - 1</div><div>        s = s * x</div><div>    return s</div></div><div>这样，当我们调用power(5)时，相当于调用power(5, 2)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; power(5)</div><div>25</div><div>&gt;&gt;&gt; power(5, 2)</div><div>25</div></div><div>而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。</div><div>从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</div><div>一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；</div><div>二是如何设置默认参数。</div><div>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</div><div>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</div><div>举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def enroll(name, gender):</div><div>    print('name:', name)</div><div>    print('gender:', gender)</div></div><div>这样，调用enroll()函数只需要传入两个参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; enroll('Sarah', 'F')</div><div>name: Sarah</div><div>gender: F</div></div><div>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。</div><div>我们可以把年龄和城市设为默认参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def enroll(name, gender, age=6, city='Beijing'):</div><div>    print('name:', name)</div><div>    print('gender:', gender)</div><div>    print('age:', age)</div><div>    print('city:', city)</div></div><div>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; enroll('Sarah', 'F')</div><div>name: Sarah</div><div>gender: F</div><div>age: 6</div><div>city: Beijing</div></div><div>只有与默认参数不符的学生才需要提供额外的信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>enroll('Bob', 'M', 7)</div><div>enroll('Adam', 'M', city='Tianjin')</div></div><div>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</div><div>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。</div><div>也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。</div><div>默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：</div><div>先定义一个函数，传入一个list，添加一个END再返回：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def add_end(L=[]):</div><div>    L.append('END')</div><div>    return L</div></div><div>当你正常调用时，结果似乎不错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; add_end([1, 2, 3])</div><div>[1, 2, 3, 'END']</div><div>&gt;&gt;&gt; add_end(['x', 'y', 'z'])</div><div>['x', 'y', 'z', 'END']</div></div><div>当你使用默认参数调用时，一开始结果也是对的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; add_end()</div><div>['END']</div></div><div>但是，再次调用add_end()时，结果就不对了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; add_end()</div><div>['END', 'END']</div><div>&gt;&gt;&gt; add_end()</div><div>['END', 'END', 'END']</div></div><div>很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。</div><div>原因解释如下：</div><div>Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">定义默认参数要牢记一点：默认参数必须指向不变对象！</span></div><div>要修改上面的例子，我们可以用None这个不变对象来实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def add_end(L=None):</div><div>    if L is None:</div><div>        L = []</div><div>    L.append('END')</div><div>    return L</div></div><div>要修改上面的例子，我们可以用None这个不变对象来实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def add_end(L=None):</div><div>    if L is None:</div><div>        L = []</div><div>    L.append('END')</div><div>    return L</div></div><div>现在，无论调用多少次，都不会有问题：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; add_end()</div><div>['END']</div><div>&gt;&gt;&gt; add_end()</div><div>['END']</div></div><div>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可变参数</span></div><div>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。</div><div>我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。</div><div>要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def calc(numbers):</div><div>    sum = 0</div><div>    for n in numbers:</div><div>        sum = sum + n * n</div><div>    return sum</div></div><div>但是调用的时候，需要先组装出一个list或tuple：</div><hr style="display:none;-evernote-encp-section-break:true;"/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; calc([1, 2, 3])</div><div>14</div><div>&gt;&gt;&gt; calc((1, 3, 5, 7))</div><div>84</div></div><div>如果利用可变参数，调用函数的方式可以简化成这样：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; calc(1, 2, 3)</div><div>14</div><div>&gt;&gt;&gt; calc(1, 3, 5, 7)</div><div>84</div></div><div>所以，我们把函数的参数改为可变参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def calc(*numbers):</div><div>    sum = 0</div><div>    for n in numbers:</div><div>        sum = sum + n * n</div><div>    return sum</div></div><div>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; calc(1, 2)</div><div>5</div><div>&gt;&gt;&gt; calc()</div><div>0</div></div><div>如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; nums = [1, 2, 3]</div><div>&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</div><div>14</div></div><div>这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; nums = [1, 2, 3]</div><div>&gt;&gt;&gt; calc(*nums)</div><div>14</div></div><div>*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">关键字参数</span></div><div>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, **kw):</div><div>    print('name:', name, 'age:', age, 'other:', kw)</div></div><div>函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Michael', 30)</div><div>name: Michael age: 30 other: {}</div></div><div>也可以传入任意个数的关键字参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Bob', 35, city='Beijing')</div><div>name: Bob age: 35 other: {'city': 'Beijing'}</div><div>&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')</div><div>name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}</div></div><div>关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</div><div>和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}</div><div>&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])</div><div>name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}</div></div><div>当然，上面复杂的调用可以用简化的写法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; extra = {'city': 'Beijing', 'job': 'Engineer'}</div><div>&gt;&gt;&gt; person('Jack', 24, **extra)</div><div>name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}</div></div><div>**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">命名关键字参数</span></div><div>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。</div><div>仍以person()函数为例，我们希望检查是否有city和job参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, **kw):</div><div>    if 'city' in kw:</div><div>        # 有city参数</div><div>        pass</div><div>    if 'job' in kw:</div><div>        # 有job参数</div><div>        pass</div><div>    print('name:', name, 'age:', age, 'other:', kw)</div></div><div>但是调用者仍可以传入不受限制的关键字参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)</div></div><div>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, *, city, job):</div><div>    print(name, age, city, job)</div></div><div>和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。</div><div>调用方式如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')</div><div>Jack 24 Beijing Engineer</div></div><div>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, *args, city, job):</div><div>    print(name, age, args, city, job)</div></div><div>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: person() takes 2 positional arguments but 4 were given</div></div><div>由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</div><div>命名关键字参数可以有缺省值，从而简化调用：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, *, city='Beijing', job):</div><div>    print(name, age, city, job)</div></div><div>由于命名关键字参数city具有默认值，调用时，可不传入city参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; person('Jack', 24, job='Engineer')</div><div>Jack 24 Beijing Engineer</div></div><div>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def person(name, age, city, job):</div><div>    # 缺少 *，city和job被视为位置参数</div><div>    pass</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">参数组合</span></div><div>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</div><div>比如定义一个函数，包含上述若干种参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def f1(a, b, c=0, *args, **kw):</div><div>    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)</div><div><br/></div><div>def f2(a, b, c=0, *, d, **kw):</div><div>    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)</div></div><div>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f1(1, 2)</div><div>a = 1 b = 2 c = 0 args = () kw = {}</div><div>&gt;&gt;&gt; f1(1, 2, c=3)</div><div>a = 1 b = 2 c = 3 args = () kw = {}</div><div>&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')</div><div>a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}</div><div>&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)</div><div>a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}</div><div>&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</div><div>a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}</div></div><div>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; args = (1, 2, 3, 4)</div><div>&gt;&gt;&gt; kw = {'d': 99, 'x': '#'}</div><div>&gt;&gt;&gt; f1(*args, **kw)</div><div>a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}</div><div>&gt;&gt;&gt; args = (1, 2, 3)</div><div>&gt;&gt;&gt; kw = {'d': 88, 'x': '#'}</div><div>&gt;&gt;&gt; f2(*args, **kw)</div><div>a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}</div></div><div>所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">不同参数调用方法对比：</span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 365px;"></col><col style="width: 750px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;">参数类型</td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>调用方法</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;"><div>特征</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>位置参数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>def power(x):</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;"><div>最简单，最基本的调用方法</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>默认参数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>def enroll(name, gender, age=6, city='Beijing'):</div><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;">name和gender位置参数，age和city是默认参数</td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>可变参数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>def calc(*numbers):</div><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;"><div>在参数前面加了一个*表示这个参数是可变参数</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>关键字参数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>def person(name, age, **kw):</div><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;"><div>关键字参数kw，前面加**表示是关键字参数，调用时可以输入或者不输入这个参数信息，也可以随意增加想要增加的信息。格式是dict</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div>命名关键字参数</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 365px; padding: 8px;"><div>def person(name, age, *, city, job):</div><div><br/></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 750px; padding: 8px;"><div>在中间加一个*表示是命名关键字参数，表示如果想要传入那些附加信息，也只能传入指定的那几个参数（此处的city，job）</div></td></tr></tbody></table><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">2.4递归函数</span></div></div><div>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</div><div>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：</div><div>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</div><div>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。</div><div>于是，fact(n)用递归的方式写出来就是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def fact(n):</div><div>    if n==1:</div><div>        return 1</div><div>    return n * fact(n - 1)</div></div><div>上面就是一个递归函数。可以试试：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; fact(1)</div><div>1</div><div>&gt;&gt;&gt; fact(5)</div><div>120</div><div>&gt;&gt;&gt; fact(100)</div><div>93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</div></div><div>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</div><div>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; fact(1000)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</div><div>  ...</div><div>  File &quot;&lt;stdin&gt;&quot;, line 4, in fact</div><div>RuntimeError: maximum recursion depth exceeded in comparison</div></div><div>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</div><div>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况</div><div>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def fact(n):</div><div>    return fact_iter(n, 1)</div><div><br/></div><div>def fact_iter(num, product):</div><div>    if num == 1:</div><div>        return product</div><div>    return fact_iter(num - 1, num * product)</div></div><div>可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。</div><div>fact(5)对应的fact_iter(5, 1)的调用如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>===&gt; fact_iter(5, 1)</div><div>===&gt; fact_iter(4, 5)</div><div>===&gt; fact_iter(3, 20)</div><div>===&gt; fact_iter(2, 60)</div><div>===&gt; fact_iter(1, 120)</div><div>===&gt; 120</div></div><div>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</div><div>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第三节：Python的高级特性</span></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">3.1切片</span></div><div>取一个list或tuple的部分元素是非常常见的操作。比如，一个list如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']</div></div><div>取前3个元素，应该怎么做？</div><div>笨办法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; [L[0], L[1], L[2]]</div><div>['Michael', 'Sarah', 'Tracy']</div></div><div>之所以是笨办法是因为扩展一下，取前N个元素就没辙了。</div><div>取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; r = []</div><div>&gt;&gt;&gt; n = 3</div><div>&gt;&gt;&gt; for i in range(n):</div><div>...     r.append(L[i])</div><div>...</div><div>&gt;&gt;&gt; r</div><div>['Michael', 'Sarah', 'Tracy']</div></div><div>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</div><div>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[0:3]</div><div>['Michael', 'Sarah', 'Tracy']</div></div><div>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</div><div>如果第一个索引是0，还可以省略：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[:3]</div><div>['Michael', 'Sarah', 'Tracy']</div></div><div>也可以从索引1开始，取出2个元素出来：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[1:3]</div><div>['Sarah', 'Tracy']</div></div><div>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[-2:]</div><div>['Bob', 'Jack']</div><div>&gt;&gt;&gt; L[-2:-1]</div><div>['Bob']</div></div><div>记住倒数第一个元素的索引是-1。</div><div>切片操作十分有用。我们先创建一个0-99的数列：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = list(range(100))</div><div>&gt;&gt;&gt; L</div><div>[0, 1, 2, 3, ..., 99]</div></div><div>可以通过切片轻松取出某一段数列。比如前10个数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[:10]</div><div>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div></div><div>后10个数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[-10:]</div><div>[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</div></div><div>前11-20个数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[10:20]</div><div>[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</div></div><div>前10个数，每两个取一个：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[:10:2]</div><div>[0, 2, 4, 6, 8]</div></div><div>所有数，每5个取一个：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[::5]</div><div>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</div></div><div>甚至什么都不写，只写[:]就可以原样复制一个list：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L[:]</div><div>[0, 1, 2, 3, ..., 99]</div></div><div>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</div><div>(0, 1, 2)</div></div><div>字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'ABCDEFG'[:3]</div><div>'ABC'</div><div>&gt;&gt;&gt; 'ABCDEFG'[::2]</div><div>'ACEG'</div></div><div>在很多编程语言中，针对字符串提供了很多各种截取函数（例如，substring），其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">3.2迭代</span></div><div>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</div><div>在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (i=0; i&lt;list.length; i++) {</div><div>    n = list[i];</div><div>}</div></div><div>可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</div><div>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}</div><div>&gt;&gt;&gt; for key in d:</div><div>...     print(key)</div><div>...</div><div>a</div><div>c</div><div>b</div></div><div>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</div><div>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。</div><div>由于字符串也是可迭代对象，因此，也可以作用于for循环：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; for ch in 'ABC':</div><div>...     print(ch)</div><div>...</div><div>A</div><div>B</div><div>C</div></div><div>所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。</div><div>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from collections import Iterable</div><div>&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代</div><div>True</div><div>&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</div><div>True</div><div>&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</div><div>False</div></div><div>最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):</div><div>...     print(i, value)</div><div>...</div><div>0 A</div><div>1 B</div><div>2 C</div></div><div>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:</div><div>...     print(x, y)</div><div>...</div><div>1 1</div><div>2 4</div><div>3 9</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">3.3列表生成式</span></div><div>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</div><div>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; list(range(1, 11))</div><div>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div></div><div>但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = []</div><div>&gt;&gt;&gt; for x in range(1, 11):</div><div>...    L.append(x * x)</div><div>...</div><div>&gt;&gt;&gt; L</div><div>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></div><div>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; [x * x for x in range(1, 11)]</div><div>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</div></div><div>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</div><div>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</div><div>[4, 16, 36, 64, 100]</div></div><div>还可以使用两层循环，可以生成全排列：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']</div><div>['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</div></div><div>三层和三层以上的循环就很少用到了。</div><div>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</div><div>&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录</div><div>['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']</div></div><div>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }</div><div>&gt;&gt;&gt; for k, v in d.items():</div><div>...     print(k, '=', v)</div><div>...</div><div>y = B</div><div>x = A</div><div>z = C</div></div><div>因此，列表生成式也可以使用两个变量来生成list：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }</div><div>&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]   #这里的+表示字符串连接，k接上一个=然后再接上一个v</div><div>['y=B', 'x=A', 'z=C']</div></div><div>最后把一个list中所有的字符串变成小写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']</div><div>&gt;&gt;&gt; [s.lower() for s in L]</div><div>['hello', 'world', 'ibm', 'apple']</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">3.4生成器</span></div><div>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</div><div>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</div><div>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; L = [x * x for x in range(10)]</div><div>&gt;&gt;&gt; L</div><div>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</div><div>&gt;&gt;&gt; g = (x * x for x in range(10))</div><div>&gt;&gt;&gt; g</div><div>&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</div></div><div>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。</div><div>我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？</div><div>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; next(g)</div><div>0</div><div>&gt;&gt;&gt; next(g)</div><div>1</div><div>&gt;&gt;&gt; next(g)</div><div>4</div><div>&gt;&gt;&gt; next(g)</div><div>9</div><div>&gt;&gt;&gt; next(g)</div><div>16</div><div>&gt;&gt;&gt; next(g)</div><div>25</div><div>&gt;&gt;&gt; next(g)</div><div>36</div><div>&gt;&gt;&gt; next(g)</div><div>49</div><div>&gt;&gt;&gt; next(g)</div><div>64</div><div>&gt;&gt;&gt; next(g)</div><div>81</div><div>&gt;&gt;&gt; next(g)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>StopIteration</div></div><div>我们讲过，generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</div><div>当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; g = (x * x for x in range(10))</div><div>&gt;&gt;&gt; for n in g:</div><div>...     print(n)</div><div>...</div><div>0</div><div>1</div><div>4</div><div>9</div><div>16</div><div>25</div><div>36</div><div>49</div><div>64</div><div>81</div></div><div>所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。</div><div>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</div><div>比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</div><div>1, 1, 2, 3, 5, 8, 13, 21, 34, ...</div><div>斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def fib(max):</div><div>    n, a, b = 0, 0, 1</div><div>    while n &lt; max:</div><div>        print(b)</div><div>        a, b = b, a + b</div><div>        n = n + 1</div><div>    return 'done'</div></div><div>仔细观察，可以看出，fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</div><div>也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def fib(max):</div><div>    n, a, b = 0, 0, 1</div><div>    while n &lt; max:</div><div>        yield b</div><div>        a, b = b, a + b</div><div>        n = n + 1</div><div>    return 'done'</div></div><div>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f = fib(6)</div><div>&gt;&gt;&gt; f</div><div>&lt;generator object fib at 0x104feaaa0&gt;</div></div><div>这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</div><div>举个简单的例子，定义一个generator，依次返回数字1，3，5：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def odd():</div><div>    print('step 1')</div><div>    yield 1</div><div>    print('step 2')</div><div>    yield(3)</div><div>    print('step 3')</div><div>    yield(5)</div></div><div>调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下一个返回值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; o = odd()</div><div>&gt;&gt;&gt; next(o)</div><div>step 1</div><div>1</div><div>&gt;&gt;&gt; next(o)</div><div>step 2</div><div>3</div><div>&gt;&gt;&gt; next(o)</div><div>step 3</div><div>5</div><div>&gt;&gt;&gt; next(o)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>StopIteration</div></div><div>可以看到，odd不是普通函数，而是generator，在执行过程中，遇到yield就中断，下次又继续执行。执行3次yield后，已经没有yield可以执行了，所以，第4次调用next(o)就报错。</div><div>回到fib的例子，我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。</div><div>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; for n in fib(6):</div><div>...     print(n)</div><div>...</div><div>1</div><div>1</div><div>2</div><div>3</div><div>5</div><div>8</div></div><div>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; g = fib(6)</div><div>&gt;&gt;&gt; while True:</div><div>...     try:</div><div>...         x = next(g)</div><div>...         print('g:', x)</div><div>...     except StopIteration as e:</div><div>...         print('Generator return value:', e.value)</div><div>...         break</div><div>...</div><div>g: 1</div><div>g: 1</div><div>g: 2</div><div>g: 3</div><div>g: 5</div><div>g: 8</div><div>Generator return value: done</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">3.5迭代器</span></div><div>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</div><div>一类是集合数据类型，如list、tuple、dict、set、str等；</div><div>一类是generator，包括生成器和带yield的generator function。</div><div>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</div><div>可以使用isinstance()判断一个对象是否是Iterable对象：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from collections import Iterable</div><div>&gt;&gt;&gt; isinstance([], Iterable)</div><div>True</div><div>&gt;&gt;&gt; isinstance({}, Iterable)</div><div>True</div><div>&gt;&gt;&gt; isinstance('abc', Iterable)</div><div>True</div><div>&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)</div><div>True</div><div>&gt;&gt;&gt; isinstance(100, Iterable)</div><div>False</div></div><div>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</div><div>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</div><div>可以使用isinstance()判断一个对象是否是Iterator对象：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from collections import Iterator</div><div>&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</div><div>True</div><div>&gt;&gt;&gt; isinstance([], Iterator)</div><div>False</div><div>&gt;&gt;&gt; isinstance({}, Iterator)</div><div>False</div><div>&gt;&gt;&gt; isinstance('abc', Iterator)</div><div>False</div></div><div>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</div><div>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(iter([]), Iterator)</div><div>True</div><div>&gt;&gt;&gt; isinstance(iter('abc'), Iterator)</div><div>True</div></div><div>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</div><div>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</div><div>凡是可作用于for循环的对象都是Iterable类型；</div><div>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</div><div>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</div><div>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># 首先获得Iterator对象:</div><div>it = iter([1, 2, 3, 4, 5])</div><div># 循环:</div><div>while True:</div><div>    try:</div><div>        # 获得下一个值:</div><div>        x = next(it)</div><div>    except StopIteration:</div><div>        # 遇到StopIteration就退出循环</div><div>        break</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第四节：函数式编程</span></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">4.1高阶函数</span></div><div><span style="font-style: italic;">变量可以指向函数</span></div><div>以Python内置的求绝对值的函数abs()为例，调用该函数用以下代码：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; abs(-10)</div><div>10</div></div><div>但是，如果只写abs呢？</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; abs</div><div>&lt;built-in function abs&gt;</div></div><div>可见，abs(-10)是函数调用，而abs是函数本身。</div><div>要获得函数调用结果，我们可以把结果赋值给变量：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; x = abs(-10)</div><div>&gt;&gt;&gt; x</div><div>10</div></div><div>但是，如果把函数本身赋值给变量呢？</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f = abs</div><div>&gt;&gt;&gt; f</div><div>&lt;built-in function abs&gt;</div></div><div>结论：函数本身也可以赋值给变量，即：变量可以指向函数。</div><div>如果一个变量指向了一个函数，那么，可否通过该变量来调用这个函数？用代码验证一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f = abs</div><div>&gt;&gt;&gt; f(-10)</div><div>10</div></div><div>成功！说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。</div><div><span style="font-style: italic;">函数名也是变量</span></div><div>那么函数名是什么呢？函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！</div><div>如果把abs指向其他对象，会有什么情况发生？</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; abs = 10</div><div>&gt;&gt;&gt; abs(-10)</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>TypeError: 'int' object is not callable</div></div><div>把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！</div><div>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。</div><div>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</div><div>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</div><div>一个最简单的高阶函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def add(x, y, f):</div><div>    return f(x) + f(y)</div><div>print(add(-5, 6, abs))</div><div><br/></div><div>11</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">map/reduce(实际就是对一连串序列同时进行操作)</span></div><div>我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; def f(x):</div><div>...     return x * x</div><div>...</div><div>&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</div><div>&gt;&gt;&gt; list(r)</div><div>[1, 4, 9, 16, 25, 36, 49, 64, 81]</div></div><div>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</div><div>你可能会想，不需要map()函数，写一个循环，也可以计算出结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>L = []</div><div>for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:</div><div>    L.append(f(n))</div><div>print(L)</div></div><div>的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？</div><div>所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</div><div>['1', '2', '3', '4', '5', '6', '7', '8', '9']</div></div><div>再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div></div><div>比方说对一个序列求和，就可以用reduce实现：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from functools import reduce</div><div>&gt;&gt;&gt; def add(x, y):</div><div>...     return x + y</div><div>...</div><div>&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</div><div>25</div></div><div>当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。</div><div>但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from functools import reduce</div><div>&gt;&gt;&gt; def fn(x, y):</div><div>...     return x * 10 + y</div><div>...</div><div>&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</div><div>13579</div></div><div>这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; from functools import reduce</div><div>&gt;&gt;&gt; def fn(x, y):</div><div>...     return x * 10 + y</div><div>...</div><div>&gt;&gt;&gt; def char2num(s):</div><div>...     digits = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}</div><div>...     return digits[s]</div><div>...</div><div>&gt;&gt;&gt; reduce(fn, map(char2num, '13579'))</div><div>13579</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">filter</span></div><div>Python内建的filter()函数用于过滤序列。</div><div>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</div><div>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def is_odd(n):</div><div>    return n % 2 == 1</div><div><br/></div><div>list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</div><div># 结果: [1, 5, 9, 15]</div></div><div>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</div><div>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">sorted</span></div><div>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</div><div>Python内置的sorted()函数就可以对list进行排序：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt; sorted([36, 5, -12, 9, -21])</div><div>[-21, -12, 5, 9, 36]</div></div><div>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)</div><div>[5, 9, -12, -21, 36]</div></div><div>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过key=abs处理过的list：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>list = [36, 5, -12, 9, -21]</div><div><br/></div><div>keys = [36, 5,  12, 9,  21]</div></div><div>然后sorted()函数按照keys进行排序，并按照对应关系返回list相应的元素：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>keys排序结果 =&gt; [5, 9,  12,  21, 36]</div><div>                |  |    |    |   |</div><div>最终结果     =&gt; [5, 9, -12, -21, 36]</div></div><div>我们再看一个字符串排序的例子：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])</div><div>['Credit', 'Zoo', 'about', 'bob']</div></div><div>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</div><div>这样，我们给sorted传入key函数，即可实现忽略大小写的排序：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)</div><div>['about', 'bob', 'Credit', 'Zoo']</div></div><div>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)</div><div>['Zoo', 'Credit', 'bob', 'about']</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">4.2</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">函数作为返回值</span></span></div><div>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</div><div>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def calc_sum(*args):</div><div>    ax = 0</div><div>    for n in args:</div><div>        ax = ax + n</div><div>    return ax</div></div><div>但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def lazy_sum(*args):</div><div>    def sum():</div><div>        ax = 0</div><div>        for n in args:</div><div>            ax = ax + n</div><div>        return ax</div><div>    return sum</div></div><div>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</div><div>&gt;&gt;&gt; f</div><div>&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</div></div><div>调用函数f时，才真正计算求和的结果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f()</div><div>25</div></div><div>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">“闭包（Closure）”</span>的程序结构拥有极大的威力。</div><div>请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</div><div>&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</div><div>&gt;&gt;&gt; f1==f2</div><div>False</div></div><div>f1()和f2()的调用结果互不影响。</div><div>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">4.3匿名函数</span></div><div>当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</div><div>在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</div><div>[1, 4, 9, 16, 25, 36, 49, 64, 81]</div></div><div>通过对比可以看出，匿名函数lambda x: x * x实际上就是：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def f(x):</div><div>    return x * x</div></div><div>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</div><div>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</div><div>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; f = lambda x: x * x</div><div>&gt;&gt;&gt; f</div><div>&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</div><div>&gt;&gt;&gt; f(5)</div><div>25</div></div><div>同样，也可以把匿名函数作为返回值返回，比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def build(x, y):</div><div>    return <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">lambda : x * x + y * y  #这一串表示的是一个函数！！！</span></div><div>t=build(1,2)</div><div>print(t())</div><div><br/></div><div>5</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">4.4偏函数</span></div><div>Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</div><div>在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：</div><div>int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; int('12345')</div><div>12345</div></div><div>但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; int('12345', base=8)</div><div>5349</div><div>&gt;&gt;&gt; int('12345', 16)</div><div>74565</div></div><div>假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def int2(x, base=2):</div><div>    return int(x, base)</div></div><div>这样，我们转换二进制就非常方便了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; int2('1000000')</div><div>64</div><div>&gt;&gt;&gt; int2('1010101')</div><div>85</div></div><div>functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import functools</div><div>&gt;&gt;&gt; int2 = functools.partial(int, base=2)</div><div>&gt;&gt;&gt; int2('1000000')</div><div>64</div><div>&gt;&gt;&gt; int2('1010101')</div><div>85</div></div><div>所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</div><div>注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; int2('1000000', base=10)</div><div>1000000</div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第五节：模块</span></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">5.1模块简介</span></div><div>计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</div><div>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</div><div>使用模块有什么好处？</div><div>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。</div><div>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。</div><div>你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</div><div>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</div><div>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：</div><div>mycompany</div><div>├─ __init__.py</div><div>├─ abc.py</div><div>└─ xyz.py</div><div>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。</div><div>请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。</div><div>类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：</div><div>mycompany</div><div>├─ web</div><div>│  ├─ __init__.py</div><div>│  ├─ utils.py</div><div>│  └─ www.py</div><div>├─ __init__.py</div><div>├─ abc.py</div><div>└─ xyz.py</div><div>文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。</div><div>自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</div><div>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</div><div>创建自己的模块时，要注意：</div><div>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</div><div>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">5.2使用模块</span></div><div>Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。</div><div>我们以内建的sys模块为例，编写一个hello的模块：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#!/usr/bin/env python3</div><div># -*- coding: utf-8 -*-</div><div><br/></div><div>' a test module '</div><div><br/></div><div>__author__ = 'Michael Liao'</div><div><br/></div><div>import sys</div><div><br/></div><div>def test():</div><div>    args = sys.argv</div><div>    if len(args)==1:</div><div>        print('Hello, world!')</div><div>    elif len(args)==2:</div><div>        print('Hello, %s!' % args[1])</div><div>    else:</div><div>        print('Too many arguments!')</div><div><br/></div><div>if __name__=='__main__':</div><div>    test()</div></div><div>第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；</div><div>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；</div><div>第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；</div><div>以上就是Python模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。</div><div>后面开始就是真正的代码部分。</div><div>你可能注意到了，使用sys模块的第一步，就是导入该模块：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import sys</div></div><div>导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</div><div>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</div><div>运行python3 hello.py获得的sys.argv就是['hello.py']；</div><div>运行python3 hello.py Michael获得的sys.argv就是['hello.py', 'Michael]。</div><div>最后，注意到这两行代码：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>if __name__=='__main__':</div><div>    test()</div></div><div>当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。<br/></div><div>我们可以用命令行运行hello.py看看效果：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python3 hello.py</div><div>Hello, world!</div><div>$ python hello.py Michael</div><div>Hello, Michael!</div></div><div>如果启动Python交互环境，再导入hello模块：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python3</div><div>Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03)</div><div>[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</div><div>Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div>&gt;&gt;&gt; import hello</div><div>&gt;&gt;&gt;</div></div><div>导入时，没有打印Hello, word!，因为没有执行test()函数。</div><div>调用hello.test()时，才能打印出Hello, word!：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; hello.test()</div><div>Hello, world!</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">作用域</span></div><div>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。</div><div>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</div><div>类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；</div><div>类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；</div><div>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</div><div>private函数或变量不应该被别人引用，那它们有什么用呢？请看例子：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def _private_1(name):</div><div>    return 'Hello, %s' % name</div><div><br/></div><div>def _private_2(name):</div><div>    return 'Hi, %s' % name</div><div><br/></div><div>def greeting(name):</div><div>    if len(name) &gt; 3:</div><div>        return _private_1(name)</div><div>    else:</div><div>        return _private_2(name)</div></div><div>我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：</div><div>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">5.3安装第三方模块</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">安装常用模块</span></div><div>在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Anaconda</span>，就相当于把数十个第三方模块自动安装好了，非常简单易用。</div><div>可以从Anaconda官网下载GUI安装包，安装包有500~600M，所以需要耐心等待下载。网速慢的同学请移步国内镜像。下载后直接安装，Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。</div><div>安装好Anaconda后，重新打开命令行窗口，输入python，可以看到Anaconda的信息：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>┌────────────────────────────────────────────────────────┐</div><div>│Command Prompt - python                           - □ x │</div><div>├────────────────────────────────────────────────────────┤</div><div>│Microsoft Windows [Version 10.0.0]                      │</div><div>│(c) 2015 Microsoft Corporation. All rights reserved.    │</div><div>│                                                        │</div><div>│C:\&gt; python                                             │</div><div>│Python 3.6.3 |Anaconda, Inc.| ... on win32              │</div><div>│Type &quot;help&quot;, ... for more information.                  │</div><div>│&gt;&gt;&gt; import numpy                                        │</div><div>│&gt;&gt;&gt; _                                                   │</div><div>│                                                        │</div><div>│                                                        │</div><div>│                                                        │</div><div>└────────────────────────────────────────────────────────┘</div></div><div>可以尝试直接import numpy等已安装的第三方模块。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">模块搜索路径</span></div><div>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import mymodule</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>ImportError: No module named mymodule</div></div><div>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import sys</div><div>&gt;&gt;&gt; sys.path</div><div>['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']</div></div><div>如果我们要添加自己的搜索目录，有两种方法：</div><div>一是直接修改sys.path，添加要搜索的目录：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import sys</div><div>&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts')</div></div><div>这种方法是在运行时修改，运行结束后失效。</div><div>第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第六节：面向对象编程</span></div><div>数据封装、继承和多态是面向对象的三大特点</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">6.1类和实例</span></div><div>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</div><div>仍以Student类为例，在Python中，定义类是通过class关键字：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    pass</div></div><div>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。</div><div>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart = Student()</div><div>&gt;&gt;&gt; bart</div><div>&lt;__main__.Student object at 0x10a67a590&gt;</div><div>&gt;&gt;&gt; Student</div><div>&lt;class '__main__.Student'&gt;</div></div><div>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。</div><div>可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart.name = 'Bart Simpson'</div><div>&gt;&gt;&gt; bart.name</div><div>'Bart Simpson'</div></div><div>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    def __init__(self, name, score):   #注意：特殊方法“__init__”前后分别有两个下划线！！！</div><div>        self.name = name</div><div>        self.score = score</div></div><div>注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。</div><div>有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)</div><div>&gt;&gt;&gt; bart.name</div><div>'Bart Simpson'</div><div>&gt;&gt;&gt; bart.score</div><div>59</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。</span>除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">数据封装</span></div><div>面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; def print_score(std):</div><div>...     print('%s: %s' % (std.name, std.score))</div><div>...</div><div>&gt;&gt;&gt; print_score(bart)</div><div>Bart Simpson: 59</div></div><div>但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    def __init__(self, name, score):</div><div>        self.name = name</div><div>        self.score = score</div><div><br/></div><div>    def print_score(self):</div><div>        print('%s: %s' % (self.name, self.score))</div></div><div>要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart.print_score()</div><div>Bart Simpson: 59</div></div><div>这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</div><div>封装的另一个好处是可以给Student类增加新的方法，比如get_grade：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    ...</div><div><br/></div><div>    def get_grade(self):</div><div>        if self.score &gt;= 90:</div><div>            return 'A'</div><div>        elif self.score &gt;= 60:</div><div>            return 'B'</div><div>        else:</div><div>            return 'C'</div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">6.2访问限制</span></div><div>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</div><div>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)</div><div>&gt;&gt;&gt; bart.score</div><div>59</div><div>&gt;&gt;&gt; bart.score = 99</div><div>&gt;&gt;&gt; bart.score</div><div>99</div></div><div>如果要让内部属性不被外部访问，可以把属性的名称前加上<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">两个</span>下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    def __init__(self, name, score):</div><div>        self.__name = name</div><div>        self.__score = score</div><div><br/></div><div>    def print_score(self):</div><div>        print('%s: %s' % (self.__name, self.__score))</div></div><div>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)</div><div>&gt;&gt;&gt; bart.__name</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>AttributeError: 'Student' object has no attribute '__name'</div></div><div>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</div><div>但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    ...</div><div><br/></div><div>    def get_name(self):</div><div>        return self.__name</div><div><br/></div><div>    def get_score(self):</div><div>        return self.__scor</div></div><div>如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    ...</div><div><br/></div><div>    def set_score(self, score):</div><div>        self.__score = score</div></div><div>你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    ...</div><div><br/></div><div>    def set_score(self, score):</div><div>        if 0 &lt;= score &lt;= 100:</div><div>            self.__score = score</div><div>        else:</div><div>            raise ValueError('bad score')</div></div><div>需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。<br/></div><div>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</div><div>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart._Student__name</div><div>'Bart Simpson'</div></div><div>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。</div><div>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</div><div>最后注意下面的这种错误写法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart = Student('Bart Simpson', 59)</div><div>&gt;&gt;&gt; bart.get_name()</div><div>'Bart Simpson'</div><div>&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！</div><div>&gt;&gt;&gt; bart.__name</div><div>'New Name'</div></div><div>表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</div><div>'Bart Simpson'</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">6.3继承和多态</span></div><div>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</div><div>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Animal(object):</div><div>    def run(self):</div><div>        print('Animal is running...')</div></div><div>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Dog(Animal):</div><div>    pass</div><div><br/></div><div>class Cat(Animal):</div><div>    pass</div></div><div>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</div><div>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>dog = Dog()</div><div>dog.run()</div><div><br/></div><div>cat = Cat()</div><div>cat.run()</div></div><div>当然，也可以对子类增加一些方法，比如Dog类：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Dog(Animal):</div><div><br/></div><div>    def run(self):</div><div>        print('Dog is running...')</div><div><br/></div><div>    def eat(self):</div><div>        print('Eating meat...')</div></div><div>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Dog(Animal):</div><div><br/></div><div>    def run(self):</div><div>        print('Dog is running...')</div><div><br/></div><div>class Cat(Animal):</div><div><br/></div><div>    def run(self):</div><div>        print('Cat is running...')</div></div><div>再次运行，结果如下：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Dog is running...</div><div>Cat is running...</div></div><div>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">多态</span>。</div><div>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>a = list() # a是list类型</div><div>b = Animal() # b是Animal类型</div><div>c = Dog() # c是Dog类型</div></div><div>判断一个变量是否是某个类型可以用isinstance()判断：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(a, list)</div><div>True</div><div>&gt;&gt;&gt; isinstance(b, Animal)</div><div>True</div><div>&gt;&gt;&gt; isinstance(c, Dog)</div><div>True</div></div><div>来a、b、c确实对应着list、Animal、Dog这3种类型。</div><div>但是等等，试试：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(c, Animal)</div><div>True</div></div><div>不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！</div><div>所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; b = Animal()</div><div>&gt;&gt;&gt; isinstance(b, Dog)</div><div>False</div></div><div>Dog可以看成Animal，但Animal不可以看成Dog。</div><div>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def run_twice(animal):</div><div>    animal.run()</div><div>    animal.run()</div></div><div>当我们传入Animal的实例时，run_twice()就打印出：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; run_twice(Animal())</div><div>Animal is running...</div><div>Animal is running...</div></div><div>当我们传入Dog的实例时，run_twice()就打印出：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; run_twice(Dog())</div><div>Dog is running...</div><div>Dog is running...</div></div><div>当我们传入Cat的实例时，run_twice()就打印出：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; run_twice(Cat())</div><div>Cat is running...</div><div>Cat is running...</div></div><div>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Tortoise(Animal):</div><div>    def run(self):</div><div>        print('Tortoise is running slowly...')</div></div><div>当我们调用run_twice()时，传入Tortoise的实例：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; run_twice(Tortoise())</div><div>Tortoise is running slowly...</div><div>Tortoise is running slowly...</div></div><div>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</div><div>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</div><div>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">“开闭”原则</span>：<br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">对扩展开放：允许新增Animal子类；</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</span></div><div>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                ┌───────────────┐</div><div>                │    object     │</div><div>                └───────────────┘</div><div>                        │</div><div>           ┌────────────┴────────────┐</div><div>           │                         │</div><div>           ▼                         ▼</div><div>    ┌─────────────┐           ┌─────────────┐</div><div>    │   Animal    │           │    Plant    │</div><div>    └─────────────┘           └─────────────┘</div><div>           │                         │</div><div>     ┌─────┴──────┐            ┌─────┴──────┐</div><div>     │            │            │            │</div><div>     ▼            ▼            ▼            ▼</div><div>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</div><div>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │</div><div>└─────────┘  └─────────┘  └─────────┘  └─────────┘</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">静态语言 vs 动态语言</span></div><div>对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。</div><div>对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Timer(object):</div><div>    def run(self):</div><div>        print('Start...')</div></div><div>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</div><div>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">小结</span></div><div>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</div><div>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">6.4获取对象信息</span></div><div>当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">type()</span></div><div>首先，我们来判断对象类型，使用type()函数：</div><div>基本类型都可以用type()判断：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; type(123)</div><div>&lt;class 'int'&gt;</div><div>&gt;&gt;&gt; type('str')</div><div>&lt;class 'str'&gt;</div><div>&gt;&gt;&gt; type(None)</div><div>&lt;type(None) 'NoneType'&gt;</div></div><div>如果一个变量指向函数或者类，也可以用type()判断：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; type(abs)</div><div>&lt;class 'builtin_function_or_method'&gt;</div><div>&gt;&gt;&gt; type(a)</div><div>&lt;class '__main__.Animal'&gt;</div></div><div>但是type()函数返回的是什么类型呢？它返回对应的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">Class类型</span>。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; type(123)==type(456)</div><div>True</div><div>&gt;&gt;&gt; type(123)==int</div><div>True</div><div>&gt;&gt;&gt; type('abc')==type('123')</div><div>True</div><div>&gt;&gt;&gt; type('abc')==str</div><div>True</div><div>&gt;&gt;&gt; type('abc')==type(123)</div><div>False</div></div><div>判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; import types</div><div>&gt;&gt;&gt; def fn():</div><div>...     pass</div><div>...</div><div>&gt;&gt;&gt; type(fn)==types.FunctionType</div><div>True</div><div>&gt;&gt;&gt; type(abs)==types.BuiltinFunctionType</div><div>True</div><div>&gt;&gt;&gt; type(lambda x: x)==types.LambdaType</div><div>True</div><div>&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorType</div><div>True</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">isinstance()</span></div><div>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。</div><div>我们回顾上次的例子，如果继承关系是：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>object -&gt; Animal -&gt; Dog -&gt; Husky</div></div><div>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; a = Animal()</div><div>&gt;&gt;&gt; d = Dog()</div><div>&gt;&gt;&gt; h = Husky()</div></div><div>然后，判断：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(h, Husky)</div><div>True</div></div><div>没有问题，因为h变量指向的就是Husky对象。</div><div>再判断：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(h, Dog)</div><div>True</div></div><div>h虽然自身是Husky类型，但由于Husky是从Dog继承下来的，所以，h也还是Dog类型。换句话说，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</div><div>因此，我们可以确信，h还是Animal类型：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance(h, Animal)</div><div>True</div></div><div>能用type()判断的基本类型也可以用isinstance()判断：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance('a', str)</div><div>True</div><div>&gt;&gt;&gt; isinstance(123, int)</div><div>True</div><div>&gt;&gt;&gt; isinstance(b'a', bytes)</div><div>True</div></div><div>并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</div><div>True</div><div>&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))</div><div>True</div></div><div>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">dir()</span></div><div>如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; dir('ABC')</div><div>['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']</div></div><div>类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; len('ABC')</div><div>3</div><div>&gt;&gt;&gt; 'ABC'.__len__()</div><div>3</div></div><div>我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class MyDog(object):</div><div>...     def __len__(self):</div><div>...         return 100</div><div>...</div><div>&gt;&gt;&gt; dog = MyDog()</div><div>&gt;&gt;&gt; len(dog)</div><div>100</div></div><div>剩下的都是普通属性或方法，比如lower()返回小写的字符串：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; 'ABC'.lower()</div><div>'abc'</div></div><div>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class MyObject(object):</div><div>...     def __init__(self):</div><div>...         self.x = 9</div><div>...     def power(self):</div><div>...         return self.x * self.x</div><div>...</div><div>&gt;&gt;&gt; obj = MyObject()</div></div><div>紧接着，可以测试该对象的属性：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？</div><div>True</div><div>&gt;&gt;&gt; obj.x</div><div>9</div><div>&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？</div><div>False</div><div>&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'</div><div>&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？</div><div>True</div><div>&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'</div><div>19</div><div>&gt;&gt;&gt; obj.y # 获取属性'y'</div><div>19</div></div><div>如果试图获取不存在的属性，会抛出AttributeError的错误：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z'</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>AttributeError: 'MyObject' object has no attribute 'z'</div></div><div>可以传入一个default参数，如果属性不存在，就返回默认值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404</div><div>404</div></div><div>也可以获得对象的方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？</div><div>True</div><div>&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'</div><div>&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</div><div>&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn</div><div>&gt;&gt;&gt; fn # fn指向obj.power</div><div>&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</div><div>&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的</div><div>81</div></div><div>一个正确的用法的例子如下：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def readImage(fp):</div><div>    if hasattr(fp, 'read'):</div><div>        return readData(fp)</div><div>    return None</div></div><div>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。</div><div>请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">6.5实例属性和类属性</span></div><div>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</div><div>给实例绑定属性的方法是通过实例变量，或者通过self变量：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    def __init__(self, name):</div><div>        self.name = name</div><div><br/></div><div>s = Student('Bob')</div><div>s.score = 90</div></div><div>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    name = 'Student'</div></div><div>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class Student(object):</div><div>...     name = 'Student'</div><div>...</div><div>&gt;&gt;&gt; s = Student() # 创建实例s</div><div>&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</div><div>Student</div><div>&gt;&gt;&gt; print(Student.name) # 打印类的name属性</div><div>Student</div><div>&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性</div><div>&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</div><div>Michael</div><div>&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</div><div>Student</div><div>&gt;&gt;&gt; del s.name # 如果删除实例的name属性</div><div>&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</div><div>Student</div></div><div>实例属性属于各个实例所有，互不干扰；</div><div>类属性属于类所有，所有实例共享一个属性；</div><div>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第七节：面向对象高级编程</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>7.1</b></span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>使用__slots__</b></span></div><div>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    pass</div></div><div>然后，尝试给实例绑定一个属性：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = Student()</div><div>&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性</div><div>&gt;&gt;&gt; print(s.name)</div><div>Michael</div></div><div>还可以尝试给实例绑定一个方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法</div><div>...     self.age = age</div><div>...</div><div>&gt;&gt;&gt; from types import MethodType</div><div>&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法</div><div>&gt;&gt;&gt; s.set_age(25) # 调用实例方法</div><div>&gt;&gt;&gt; s.age # 测试结果</div><div>25</div></div><div>但是，给一个实例绑定的方法，对另一个实例是不起作用的：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s2 = Student() # 创建新的实例</div><div>&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>AttributeError: 'Student' object has no attribute 'set_age'</div></div><div>为了给所有实例都绑定方法，可以给class绑定方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; def set_score(self, score):</div><div>...     self.score = score</div><div>...</div><div>&gt;&gt;&gt; Student.set_score = set_score</div></div><div>给class绑定方法后，所有实例均可调用：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s.set_score(100)</div><div>&gt;&gt;&gt; s.score</div><div>100</div><div>&gt;&gt;&gt; s2.set_score(99)</div><div>&gt;&gt;&gt; s2.score</div><div>99</div></div><div>通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。<br/></div><div>使用__slots__</div><div>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。</div><div>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称</div></div><div>然后，我们试试：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = Student() # 创建新的实例</div><div>&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'</div><div>&gt;&gt;&gt; s.age = 25 # 绑定属性'age'</div><div>&gt;&gt;&gt; s.score = 99 # 绑定属性'score'</div><div>Traceback (most recent call last):</div><div>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div>AttributeError: 'Student' object has no attribute 'score'</div></div><div>由于'score'没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。</div><div>使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class GraduateStudent(Student):</div><div>...     pass</div><div>...</div><div>&gt;&gt;&gt; g = GraduateStudent()</div><div>&gt;&gt;&gt; g.score = 9999</div></div><div>除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">7.2</span><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>使用@property</b></span></div><div>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>s = Student()</div><div>s.score = 9999</div></div><div>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    def get_score(self):</div><div>         return self._score</div><div><br/></div><div>    def set_score(self, value):</div><div>        if not isinstance(value, int):</div><div>            raise ValueError('score must be an integer!')</div><div>        if value &lt; 0 or value &gt; 100:</div><div>            raise ValueError('score must between 0 ~ 100!')</div><div>        self._score = value</div></div><div>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = Student()</div><div>&gt;&gt;&gt; s.set_score(60) # ok!</div><div>&gt;&gt;&gt; s.get_score()</div><div>60</div><div>&gt;&gt;&gt; s.set_score(9999)</div><div>Traceback (most recent call last):</div><div>  ...</div><div>ValueError: score must between 0 ~ 100!</div></div><div>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</div><div>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</div><div>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    @property</div><div>    def score(self):</div><div>        return self._score</div><div><br/></div><div>    @score.setter</div><div>    def score(self, value):</div><div>        if not isinstance(value, int):</div><div>            raise ValueError('score must be an integer!')</div><div>        if value &lt; 0 or value &gt; 100:</div><div>            raise ValueError('score must between 0 ~ 100!')</div><div>        self._score = value</div></div><div>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = Student()</div><div>&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</div><div>&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</div><div>60</div><div>&gt;&gt;&gt; s.score = 9999</div><div>Traceback (most recent call last):</div><div>  ...</div><div>ValueError: score must between 0 ~ 100!</div></div><div>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</div><div>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div><br/></div><div>    @property</div><div>    def birth(self):</div><div>        return self._birth</div><div><br/></div><div>    @birth.setter</div><div>    def birth(self, value):</div><div>        self._birth = value</div><div><br/></div><div>    @property</div><div>    def age(self):</div><div>        return 2015 - self._birth</div></div><div>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。</div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">7.3多重继承</span></div><div>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</div><div>回忆一下Animal类层次的设计，假设我们要实现以下4种动物：</div><div>Dog - 狗狗；</div><div>Bat - 蝙蝠；</div><div>Parrot - 鹦鹉；</div><div>Ostrich - 鸵鸟。</div><div>如果按照哺乳动物和鸟类归类，我们可以设计出这样的类的层次：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                ┌───────────────┐</div><div>                │    Animal     │</div><div>                └───────────────┘</div><div>                        │</div><div>           ┌────────────┴────────────┐</div><div>           │                         │</div><div>           ▼                         ▼</div><div>    ┌─────────────┐           ┌─────────────┐</div><div>    │   Mammal    │           │    Bird     │</div><div>    └─────────────┘           └─────────────┘</div><div>           │                         │</div><div>     ┌─────┴──────┐            ┌─────┴──────┐</div><div>     │            │            │            │</div><div>     ▼            ▼            ▼            ▼</div><div>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</div><div>│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │</div><div>└─────────┘  └─────────┘  └─────────┘  └─────────┘</div></div><div>但是如果按照“能跑”和“能飞”来归类，我们就应该设计出这样的类的层次：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                ┌───────────────┐</div><div>                │    Animal     │</div><div>                └───────────────┘</div><div>                        │</div><div>           ┌────────────┴────────────┐</div><div>           │                         │</div><div>           ▼                         ▼</div><div>    ┌─────────────┐           ┌─────────────┐</div><div>    │  Runnable   │           │   Flyable   │</div><div>    └─────────────┘           └─────────────┘</div><div>           │                         │</div><div>     ┌─────┴──────┐            ┌─────┴──────┐</div><div>     │            │            │            │</div><div>     ▼            ▼            ▼            ▼</div><div>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</div><div>│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │</div><div>└─────────┘  └─────────┘  └─────────┘  └─────────┘</div></div><div>如果要把上面的两种分类都包含进来，我们就得设计更多的层次：</div><div>哺乳类：能跑的哺乳类，能飞的哺乳类；</div><div>鸟类：能跑的鸟类，能飞的鸟类。</div><div>这么一来，类的层次就复杂了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>                ┌───────────────┐</div><div>                │    Animal     │</div><div>                └───────────────┘</div><div>                        │</div><div>           ┌────────────┴────────────┐</div><div>           │                         │</div><div>           ▼                         ▼</div><div>    ┌─────────────┐           ┌─────────────┐</div><div>    │   Mammal    │           │    Bird     │</div><div>    └─────────────┘           └─────────────┘</div><div>           │                         │</div><div>     ┌─────┴──────┐            ┌─────┴──────┐</div><div>     │            │            │            │</div><div>     ▼            ▼            ▼            ▼</div><div>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</div><div>│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │</div><div>└─────────┘  └─────────┘  └─────────┘  └─────────┘</div><div>     │            │            │            │</div><div>     │            │            │            │</div><div>     ▼            ▼            ▼            ▼</div><div>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</div><div>│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │</div><div>└─────────┘  └─────────┘  └─────────┘  └─────────┘</div></div><div>果要再增加“宠物类”和“非宠物类”，这么搞下去，类的数量会呈指数增长，很明显这样设计是不行的。</div><div>正确的做法是采用多重继承。首先，主要的类层次仍按照哺乳类和鸟类设计：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Animal(object):</div><div>    pass</div><div><br/></div><div># 大类:</div><div>class Mammal(Animal):</div><div>    pass</div><div><br/></div><div>class Bird(Animal):</div><div>    pass</div><div><br/></div><div># 各种动物:</div><div>class Dog(Mammal):</div><div>    pass</div><div><br/></div><div>class Bat(Mammal):</div><div>    pass</div><div><br/></div><div>class Parrot(Bird):</div><div>    pass</div><div><br/></div><div>class Ostrich(Bird):</div><div>    pass</div></div><div>现在，我们要给动物再加上Runnable和Flyable的功能，只需要先定义好Runnable和Flyable的类：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Runnable(object):</div><div>    def run(self):</div><div>        print('Running...')</div><div><br/></div><div>class Flyable(object):</div><div>    def fly(self):</div><div>        print('Flying...')</div></div><div>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Dog(Mammal, Runnable):</div><div>    pass</div></div><div>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Bat(Mammal, Flyable):</div><div>    pass</div></div><div>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">MixIn</span></div><div>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。</div><div>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):</div><div>    pass</div></div><div>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">只允许单一继承的语言（如Java）不能使用MixIn的设计。</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">7.4定制类</span></div><div>看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。</div><div>__slots__我们已经知道怎么用了，__len__()方法我们也知道是为了能让class作用于len()函数。</div><div>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">__str__</span></div><div>我们先定义一个Student类，打印一个实例：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class Student(object):</div><div>...     def __init__(self, name):</div><div>...         self.name = name</div><div>...</div><div>&gt;&gt;&gt; print(Student('Michael'))</div><div>&lt;__main__.Student object at 0x109afb190&gt;</div></div><div>打印出一堆&lt;__main__.Student object at 0x109afb190&gt;，不好看。</div><div>怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; class Student(object):</div><div>...     def __init__(self, name):</div><div>...         self.name = name</div><div>...     def __str__(self):</div><div>...         return 'Student object (name: %s)' % self.name</div><div>...</div><div>&gt;&gt;&gt; print(Student('Michael'))</div><div>Student object (name: Michael)</div></div><div>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</div><div>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; s = Student('Michael')</div><div>&gt;&gt;&gt; s</div><div>&lt;__main__.Student object at 0x109afb310&gt;</div></div><div>这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。</div><div>解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Student(object):</div><div>    def __init__(self, name):</div><div>        self.name = name</div><div>    def __str__(self):</div><div>        return 'Student object (name=%s)' % self.name</div><div>    __repr__ = __str__</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">__iter__</span></div><div>如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</div><div>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Fib(object):</div><div>    def __init__(self):</div><div>        self.a, self.b = 0, 1 # 初始化两个计数器a，b</div><div><br/></div><div>    def __iter__(self):</div><div>        return self # 实例本身就是迭代对象，故返回自己</div><div><br/></div><div>    def __next__(self):</div><div>        self.a, self.b = self.b, self.a + self.b # 计算下一个值</div><div>        if self.a &gt; 100000: # 退出循环的条件</div><div>            raise StopIteration()</div><div>        return self.a # 返回下一个值</div></div><div>现在，试试把Fib实例作用于for循环：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; for n in Fib():</div><div>...     print(n)</div><div>...</div><div>1</div><div>1</div><div>2</div><div>3</div><div>5</div><div>...</div><div>46368</div><div>75025</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">7.5枚举类</span></div><div>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>JAN = 1</div><div>FEB = 2</div><div>MAR = 3</div><div>...</div><div>NOV = 11</div><div>DEC = 12</div></div><div>好处是简单，缺点是类型是int，并且仍然是变量。</div><div>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from enum import Enum</div><div><br/></div><div>Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))</div></div><div>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for name, member in Month.__members__.items():</div><div>    print(name, '=&gt;', member, ',', member.value)</div></div><div>value属性则是自动赋给成员的int常量，默认从1开始计数。</div><div>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>from enum import Enum, unique</div><div><br/></div><div>@unique</div><div>class Weekday(Enum):</div><div>    Sun = 0 # Sun的value被设定为0</div><div>    Mon = 1</div><div>    Tue = 2</div><div>    Wed = 3</div><div>    Thu = 4</div><div>    Fri = 5</div><div>    Sat = 6</div></div><div>@unique装饰器可以帮助我们检查保证没有重复值。</div><div>访问这些枚举类型可以有若干种方法：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&gt;&gt;&gt; day1 = Weekday.Mon</div><div>&gt;&gt;&gt; print(day1)</div><div>Weekday.Mon</div><div>&gt;&gt;&gt; print(Weekday.Tue)</div><div>Weekday.Tue</div><div>&gt;&gt;&gt; print(Weekday['Tue'])</div><div>Weekday.Tue</div><div>&gt;&gt;&gt; print(Weekday.Tue.value)</div><div>2</div><div>&gt;&gt;&gt; print(day1 == Weekday.Mon)</div><div>True</div><div>&gt;&gt;&gt; print(day1 == Weekday.Tue)</div><div>False</div><div>&gt;&gt;&gt; print(Weekday(1))</div><div>Weekday.Mon</div><div>&gt;&gt;&gt; print(day1 == Weekday(1))</div><div>True</div><div>&gt;&gt;&gt; Weekday(7)</div><div>Traceback (most recent call last):</div><div>  ...</div><div>ValueError: 7 is not a valid Weekday</div><div>&gt;&gt;&gt; for name, member in Weekday.__members__.items():</div><div>...     print(name, '=&gt;', member)</div><div>...</div><div>Sun =&gt; Weekday.Sun</div><div>Mon =&gt; Weekday.Mon</div><div>Tue =&gt; Weekday.Tue</div><div>Wed =&gt; Weekday.Wed</div><div>Thu =&gt; Weekday.Thu</div><div>Fri =&gt; Weekday.Fri</div><div>Sat =&gt; Weekday.Sat</div></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">7.6使用元类</span></div><div>略</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第八节：错误、调试和测试</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>8.1错误处理</b></span></div><div>高级语言通常都内置了一套try...except...finally...的错误处理机制</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">try</span></div><div>让我们用一个例子来看看try的机制：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try:</div><div>    print('try...')</div><div>    r = 10 / 0</div><div>    print('result:', r)</div><div>except ZeroDivisionError as e:</div><div>    print('except:', e)</div><div>finally:</div><div>    print('finally...')</div><div>print('END')</div></div><div>当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此，执行完毕。</div><div>上面的代码在计算10 / 0时会产生一个除法运算错误：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try...</div><div>except: division by zero</div><div>finally...</div><div>END</div></div><div>从输出可以看到，当错误发生时，后续语句print('result:', r)不会被执行，except由于捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继续按照流程往下走。</div><div>如果把除数0改成2，则执行结果如下：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try...</div><div>result: 5</div><div>finally...</div><div>END</div></div><div>由于没有错误发生，所以except语句块不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</div><div>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的except语句块处理。没错，可以有多个except来捕获不同类型的错误：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try:</div><div>    print('try...')</div><div>    r = 10 / int('a')</div><div>    print('result:', r)</div><div>except ValueError as e:</div><div>    print('ValueError:', e)</div><div>except ZeroDivisionError as e:</div><div>    print('ZeroDivisionError:', e)</div><div>finally:</div><div>    print('finally...')</div><div>print('END')</div></div><div>int()函数可能会抛出ValueError，所以我们用一个except捕获ValueError，用另一个except捕获ZeroDivisionError。</div><div>此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try:</div><div>    print('try...')</div><div>    r = 10 / int('2')</div><div>    print('result:', r)</div><div>except ValueError as e:</div><div>    print('ValueError:', e)</div><div>except ZeroDivisionError as e:</div><div>    print('ZeroDivisionError:', e)</div><div>else:</div><div>    print('no error!')</div><div>finally:</div><div>    print('finally...')</div><div>print('END')</div></div><div>Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try:</div><div>    foo()</div><div>except ValueError as e:</div><div>    print('ValueError')</div><div>except UnicodeError as e:</div><div>    print('UnicodeError')</div></div><div>第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了。</div><div>Python所有的错误都是从BaseException类派生的，常见的错误类型和继承关系看这里：</div><div><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></div><div>使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def foo(s):</div><div>    return 10 / int(s)</div><div><br/></div><div>def bar(s):</div><div>    return foo(s) * 2</div><div><br/></div><div>def main():</div><div>    try:</div><div>        bar('0')</div><div>    except Exception as e:</div><div>        print('Error:', e)</div><div>    finally:</div><div>        print('finally...')</div></div><div>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写try...except...finally的麻烦。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">调用栈</span></div><div>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。来看看err.py：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err.py:</div><div>def foo(s):</div><div>    return 10 / int(s)</div><div><br/></div><div>def bar(s):</div><div>    return foo(s) * 2</div><div><br/></div><div>def main():</div><div>    bar('0')</div><div><br/></div><div>main()</div></div><div>执行，结果如下：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python3 err.py</div><div>Traceback (most recent call last):</div><div>  File &quot;err.py&quot;, line 11, in &lt;module&gt;</div><div>    main()</div><div>  File &quot;err.py&quot;, line 9, in main</div><div>    bar('0')</div><div>  File &quot;err.py&quot;, line 6, in bar</div><div>    return foo(s) * 2</div><div>  File &quot;err.py&quot;, line 3, in foo</div><div>    return 10 / int(s)</div><div>ZeroDivisionError: division by zero</div></div><div>出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链：</div><div>错误信息第1行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Traceback (most recent call last):</div></div><div>告诉我们这是错误的跟踪信息。</div><div>第2~3行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>File &quot;err.py&quot;, line 11, in &lt;module&gt;</div><div>    main()</div></div><div>调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>  File &quot;err.py&quot;, line 9, in main</div><div>    bar('0')</div></div><div>调用bar('0')出错了，在代码文件err.py的第9行代码，但原因是第6行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>File &quot;err.py&quot;, line 6, in bar</div><div>    return foo(s) * 2</div></div><div>原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>  File &quot;err.py&quot;, line 3, in foo</div><div>    return 10 / int(s)</div></div><div>原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ZeroDivisionError: integer division or modulo by zero</div></div><div>根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头。<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</div></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">记录错误</span></div><div>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</div><div>Python内置的logging模块可以非常容易地记录错误信息：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err_logging.py</div><div><br/></div><div>import logging</div><div><br/></div><div>def foo(s):</div><div>    return 10 / int(s)</div><div><br/></div><div>def bar(s):</div><div>    return foo(s) * 2</div><div><br/></div><div>def main():</div><div>    try:</div><div>        bar('0')</div><div>    except Exception as e:</div><div>        logging.exception(e)</div><div><br/></div><div>main()</div><div>print('END')</div></div><div>同样是出错，但程序打印完错误信息后会继续执行，并正常退出：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python3 err_logging.py</div><div>ERROR:root:division by zero</div><div>Traceback (most recent call last):</div><div>  File &quot;err_logging.py&quot;, line 13, in main</div><div>    bar('0')</div><div>  File &quot;err_logging.py&quot;, line 9, in bar</div><div>    return foo(s) * 2</div><div>  File &quot;err_logging.py&quot;, line 6, in foo</div><div>    return 10 / int(s)</div><div>ZeroDivisionError: division by zero</div><div>END</div></div><div>通过配置，logging还可以把错误记录到日志文件里，方便事后排查。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">抛出错误</span></div><div>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</div><div>如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，用raise语句抛出一个错误的实例：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err_raise.py</div><div>class FooError(ValueError):</div><div>    pass</div><div><br/></div><div>def foo(s):</div><div>    n = int(s)</div><div>    if n==0:</div><div>        raise FooError('invalid value: %s' % s)</div><div>    return 10 / n</div><div><br/></div><div>foo('0')</div></div><div>执行，可以最后跟踪到我们自己定义的错误：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python3 err_raise.py</div><div>Traceback (most recent call last):</div><div>  File &quot;err_throw.py&quot;, line 11, in &lt;module&gt;</div><div>    foo('0')</div><div>  File &quot;err_throw.py&quot;, line 8, in foo</div><div>    raise FooError('invalid value: %s' % s)</div><div>__main__.FooError: invalid value: 0</div></div><div>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</div><div>最后，我们来看另一种错误处理的方式：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err_reraise.py</div><div><br/></div><div>def foo(s):</div><div>    n = int(s)</div><div>    if n==0:</div><div>        raise ValueError('invalid value: %s' % s)</div><div>    return 10 / n</div><div><br/></div><div>def bar():</div><div>    try:</div><div>        foo('0')</div><div>    except ValueError as e:</div><div>        print('ValueError!')</div><div>        raise</div><div><br/></div><div>bar()</div></div><div>在bar()函数中，我们明明已经捕获了错误，但是，打印一个ValueError!后，又把错误通过raise语句抛出去了，这不有病么？</div><div>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</div><div>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>try:</div><div>    10 / 0</div><div>except ZeroDivisionError:</div><div>    raise ValueError('input error!')</div></div><div>只要是合理的转换逻辑就可以，但是，决不应该把一个IOError转换成毫不相干的ValueError。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">8.2调试</span></div><div>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">第一种方法</span>简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def foo(s):</div><div>    n = int(s)</div><div>    print('&gt;&gt;&gt; n = %d' % n)</div><div>    return 10 / n</div><div><br/></div><div>def main():</div><div>    foo('0')</div><div><br/></div><div>main()</div></div><div>执行后在输出中查找打印的变量值：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python err.py</div><div>&gt;&gt;&gt; n = 0</div><div>Traceback (most recent call last):</div><div>  ...</div><div>ZeroDivisionError: integer division or modulo by zero</div></div><div>用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">断言</span></div><div>凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>def foo(s):</div><div>    n = int(s)</div><div>    assert n != 0, 'n is zero!'</div><div>    return 10 / n</div><div><br/></div><div>def main():</div><div>    foo('0')</div></div><div>assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。</div><div>如果断言失败，assert语句本身就会抛出AssertionError：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python err.py</div><div>Traceback (most recent call last):</div><div>  ...</div><div>AssertionError: n is zero!</div></div><div>程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python -O err.py</div><div>Traceback (most recent call last):</div><div>  ...</div><div>ZeroDivisionError: division by zero</div></div><div>关闭后，你可以把所有的assert语句当成pass来看。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">logging</span></div><div>把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import logging</div><div><br/></div><div>s = '0'</div><div>n = int(s)</div><div>logging.info('n = %d' % n)</div><div>print(10 / n)</div></div><div>logging.info()就可以输出一段文本。运行，发现除了ZeroDivisionError，没有任何信息。怎么回事？</div><div>别急，在import logging之后添加一行配置再试试：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import logging</div><div>logging.basicConfig(level=logging.INFO)</div></div><div>看到输出了：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python err.py</div><div>INFO:root:n = 0</div><div>Traceback (most recent call last):</div><div>  File &quot;err.py&quot;, line 8, in &lt;module&gt;</div><div>    print(10 / n)</div><div>ZeroDivisionError: division by zero</div></div><div>这就是logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</div><div>logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">pdb</span></div><div>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err.py</div><div>s = '0'</div><div>n = int(s)</div><div>print(10 / n)</div></div><div>然后启动：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python -m pdb err.py</div><div>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</div><div>-&gt; s = '0'</div></div><div>以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = '0'。输入命令l来查看代码：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(Pdb) l</div><div>  1     # err.py</div><div>  2  -&gt; s = '0'</div><div>  3     n = int(s)</div><div>  4     print(10 / n)</div></div><div>输入命令n可以单步执行代码：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(Pdb) n</div><div>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()</div><div>-&gt; n = int(s)</div><div>(Pdb) n</div><div>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()</div><div>-&gt; print(10 / n)</div></div><div>任何时候都可以输入命令p 变量名来查看变量：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(Pdb) p s</div><div>'0'</div><div>(Pdb) p n</div><div>0</div></div><div>输入命令q结束调试，退出程序：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>(Pdb) q</div></div><div>这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">pdb.set_trace()</span></div><div>这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># err.py</div><div>import pdb</div><div><br/></div><div>s = '0'</div><div>n = int(s)</div><div>pdb.set_trace() # 运行到这里会自动暂停</div><div>print(10 / n)</div></div><div>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：<br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>$ python err.py</div><div>&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()</div><div>-&gt; print(10 / n)</div><div>(Pdb) p n</div><div>0</div><div>(Pdb) c</div><div>Traceback (most recent call last):</div><div>  File &quot;err.py&quot;, line 7, in &lt;module&gt;</div><div>    print(10 / n)</div><div>ZeroDivisionError: division by zero</div></div><div>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">IDE</span></div><div>如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的IDE。目前比较好的Python IDE有：</div><div>Visual Studio Code：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，需要安装Python插件。</div><div>PyCharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a></div><div>另外，Eclipse加上pydev插件也可以调试Python程序。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 